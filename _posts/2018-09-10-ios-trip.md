---
layout: post
title:  IOS开发旅程
categories: ios
tags:
author: kongkongye
---

* content
{:toc}

包含一些自我的想法,与熟悉的java语言的比较,项目的进化旅程等.




## 使用什么语言开发IOS应用?
`Objective-C`或`Swift`,考虑到Objc比较成熟稳定,Swift则相对比较新,
因此在语言上打算先学Objc,等熟悉了再尝试Swift(这也是网上大部分人的推荐).

但对于比较新的,更简洁优雅的,从Objc的经验上催生的Swift,的确应该抱着谦虚的态度去学习.

## 使用什么IDE(集成开发环境)?
苹果官方出的`XCode`,这个没什么好说的.

## Git支持?
目前XCode新建项目时自带了初始化Git的选项,并且XCode已经集成了Git功能,比如修改的文件会显示`M`,新增的文件会显示`A`.
这说明Git是可行并且是官方推荐的.
对于常用简单的git操作,XCode自带的已经可以了,当然复杂的git操作可以用命令行或其它git工具进行.

只是`.gitignore`文件仍然需要自己建立,至于内容,则直接参考[gitignore](https://github.com/github/gitignore)上的`Objective-C.gitignore`.

## Objc是什么?怎么学?
首先看字面上的意思 -- 面向对象的C,即它是`C`语言的扩展,在其上添加了`面向对象`(OOP)特性.
事实上,Objc是C语言的严格超集.

至于添加的面向对象特性,可以简单的概括为3点:

1. 封装: 就是把`数据`与`方法`打包在一起,对外隐藏具体实现.
2. 继承: 利用现有类的功能,无需重新编写相同的代码,对现有功能进行扩展.
3. 多态: 主要包括`覆盖`与`重载`,覆盖就是子类重新定义父类的方法,重载就是允许存在多个名字相同的函数,但参数不同.

  但要注意的是,在Objc里并不存在重载,因为它只认函数名,不认参数类型.

## 包与命名空间?
不像java有`包`,c++有`命名空间`,Objc里没有这种机制...(听说这个点是争论比较大的)

但替代的,Objc里通常以`前缀`来区分.比如官方核心的`NS`前缀,像`NSObject`,`NSArray`等.

前缀冲突怎么办?这个没什么办法,官方建议`两个字母`作为前缀的类名是为官方的库与框架准备的;第三方库应该使用`三个或更多字母`来作为前缀

除了`类名`,`方法名`也应该加前缀(这个甚至更严重?!),否则...一旦冲突,自己cry吧.

## objc有哪些数据类型?
objc是C语言的超集,那么先说说C语言有哪些数据类型:

1. 基本数据类型
  * 整数
    * char
    * short
    * int
    * long
    * ...
  * 浮点数
    * float
    * double
    * ...
  * bool
2. 枚举
3. void: 没有值,通常用于以下情形:
  1. 函数返回为空
  2. 函数参数为空
  3. 指针指向void(类型为void \*)
4. 派生类型
  * 指针pointer
  * 数组
  * 结构struct
  * 共用体union
  * 函数function (指函数返回值类型)

数组与结构类型统称为`聚合`类型.

然后objc附加了以下的数据类型:

1. 派生类型
  * NSValue: 这是个可以和各种基本数据类型互转的类
  * NSNumber: 继承自NSValue,数字的包装类
  * NSString: 这是一个类,基本上代替了char与string的使用
  * NSArray: 数组
  * ...
2. id类型: 表示任意类型(只表示对象类型,不表示基本数据类型),类型于js语言的var

objc类型封装?
objc在c的基础上,对类型作了一些封装(其实就是别名),如`int`与`NSInteger`,`float`与`CGFloat`等.
那么使用原始的类型还是封装的类型更好呢?
推荐使用封装的类型,这样可以屏蔽底层实现细节.

`NSInteger`与`NSNumber`的区别?
NSInteger是数据类型,而NSNumber是一个类.
比如NSArray里只能放类,因此`3`这样的基础数据类型是无法放入的,而包装成`@3`类后即可放入.

ps: 数据类型这块还是比较乱,后面再整理

## 消息
Objc使用消息(Message)来调用方法,消息格式为: `[对象或者类名字 方法名字:参数序列];`,其中:

* `整个消息格式`称为消息表达式(Message expression)
* `对象或类名字`称作接收器(Receiver)
* `方法名字:参数序列`称作消息(Message)
* `方法名字`称作选择器(Selector)或关键字(Keyword)

编译器会检查方法是否有效,如果无效会产生一个警告,但并不会阻止程序启动,
因为objc的动态性,它只有在运行期才会去查找并触发消息,这种机制带来了很大的灵活性.

## 内存管理
对c语言来说,内存需要手动分配与释放,因此在objc里也类似.
在objc里,内存管理主要靠`retain count`(引用计数),在`alloc`,`retain`,`copy`时会加1,在`release`时会减1.

#### 问题是什么?
内存管理主要有两个问题:

1. 释放正在使用的对象: 程序崩溃
2. 未释放不再使用的对象: 内存泄露

#### 规则是什么?
内存管理的规则也很简单:

1. 我们拥有创建的对象,不再使用时必须进行释放
2. retain后不再使用时也必须release
3. 不释放非自己拥有的对象

为了加深理解,举个例子,新建一个NSURLConnection连接,但是请求是异步返回的,那什么时候释放呢?
很简单,NSURLConnection对象用完就释放,它会在发送请求时将自己retain一次,请求返回时又会自动release一次.
因此你不用理它,管好自己就行,用完就释放.

#### ARC(Automic Reference Counting)
新版本的objc引入了ARC,管理内存的自动释放(对应的是MRC).

要注意的是这个是在`编译`时期(而非运行时期)自动在代码中插入合适的内存管理代码(类似插入retain,release,autorelease吧).
此外在运行期也会有一些优化.

## 项目文件结构
目标:

1. 目录结构清晰
2. 快速找到文件
3. 减少依赖,增加可移植性

基本概念:

* 主要的项目功能: 外层先按`功能模块`分,内层再按`MVC`分.
* 工具类等功能: 单独的目录.
* 模块内可以包含子模块,但建议层次不超过三级.

具体结构设计:

* `Class`: 存放所有模块功能
* `Base`: 存放基类
* `Vendor`: 第三方(主要的第三方用cocoapods,小的放这里)
* `Framework`: 类库
* `Resource`: 存放资源
* `Support`: 工具类,分类,宏定义,PCH文件等
* `Main`: AppDelegate相关

## XCode项目结构
* Workspace: 就是工作空间,里面可以包含多个项目,为什么?比如这些项目间有关联.
  * Project: 项目的意思(这才是主体),包含构建一个或多个软件产品所需的所有文件,资源和信息
    * Target: 指定要构建的产品,并包含构建需要的文件说明.target之间可以互相独立或依赖.
* Scheme: 定义可构建的Target以及构建时使用的构建信息

在`Project Navigator`中,选择项目,右侧会展示`Project Editor`,这里可以看到所有的Target.
此外,可以看到产品信息和构建配置(Build Settings),其中构建配置内的大部分配置项还区分`Debug`与`Release`.
Debug就是多输出一些调试信息,Release会进行代码优化.

关于Workspace的作用,可以拿Cocospods举例,
当使用Cocospods来管理第三方时,会自动新建一个跟原项目平行的Pods项目,里面放置第三方依赖.
原先打开的是一个名为`app.xcodeproj`的`项目`,现在改为打开cocospods自动生成的名为`app.xcworkspace`的`工作空间`,
工作空间里有原来的项目,与放置第三方依赖的Pods项目.

Target使用场景?

1. 用来区分免费版与收费版,主体上功能差不多,一些地方有区别.
2. 用来区分开发与生产环境
3. 用来区分ios与ipad?

Scheme使用场景?

1. 打测试包与正式包

## XCode界面开发
### Interface Builder
XCode中编辑界面的工具叫`Interface Builder`,关于这个工具:
之前是个独立软件,创建的文件是二进制格式nib.
后来集成到XCode内,为了方便版本控制,创建的文件是xib(xml文件格式),
在工程编译的时候再转为nib格式.

### 方式
界面开发主要有以下几种方式:

1. 代码: 复杂的大项目推荐使用这种方式
  * 缺点:
    * 不直观,没法所见即所得,只能写完,然后运行才能看到效果
2. xib
3. storyboard(最新&官方推荐): 类似xib的集合,每个xib对应一个场景,可以设置场景关系(表现为一些连线)
  * IBOutlet: 就是引用了,让代码可以操控界面元素(它会解析为nothing,仅作为与界面相关的标记,如`IBOutlet UILabel *title;`)
  * IBAction: 比如点击按钮执行相应的方法(它会解析为void,同时也作为与界面相关的标记,如`- (IBAction)ok:(id)sender;`)
  * segue: 页面跳转方式(奇怪的名字)

    这是什么鬼?花了我好多时间研究.
    首先它是名为`UIStoryboardSegue`的类,里面有id,来源UIViewController,目标UIViewController这几个字段,还有个`perform`方法.这就有些明了了,执行一个segue其实就是调用一下perform方法,然后在来源与目标ViewController之间做点操作而已,比如跳转,返回.

  * 缺点(继承了xib的所有缺点- -!):
    * 打开比较慢(因为多个场景同时展示)
    * 屏幕小时,编辑起来很挤
    * 多人编辑时,合并容易冲突: 因此实际工作中,一个storyboard最好只由一个人负责

吐槽: IBOutlet与IBAction的用法真奇葩,还不一样...两个都有标记的作用,标识着可以与界面产生交互(连线),但IBAction竟然代替了void的位置.

#### triggered segue/presenting segue
* triggered segue: 就是用来触发segue的
* presenting segue: 就是用来接受触发的

(明白这两种的区别,segue就很简单明了了)

#### 自动/手动的segue
* 自动型的segue: 比如从按钮直接拖线到另一个ViewController,action选择show,这样点击按钮就会跳转页面.自动型的没法加条件判断哦,要加可以使用手动的.
* 手动型的segue: 在ViewController上右键,最上方的manual连线到另一个ViewController,action比如选择show.那么怎么触发这个segue呢?先选中这个,在`Attributes inspector`中设置identifier,然后比如点击按钮执行方法,在方法内使用`[self performSegueWithIdentifier:@"id" sender:nil];`即可手动执行segue了

#### segue类型
1. modal(iphone&ipad): 最常用的,新的场景覆盖旧的,必须先关闭这个场景才能与上个场景交互
2. push(iphone&ipad): 这种一般需要第一个界面是`Navigation Controller`,下一级使用那种右侧划入的方式
3. custom(iphone&ipad): 自定义方式
4. popover(ipad): 浮窗形式
5. replace(ipad): 替换当前scene,经常用在ipad的特殊视图上(spit-view)
6. unwind segue(或叫exit segue): 简单说就是返回,从页面A返回到页面B,连线时需要指定一个方法`- (IBAction) unwindToThisViewController:(UIStoryboardSegue *) segue`,这个方法写在B内(方法名随意).
   执行这个segue时(如按钮或代码调用),就会执行这个方法并返回到B(执行方法在segue的perform前).

#### segue跳转代码
```objc
//根据 segue Identifier跳转界面
[self performSegueWithIdentifier:@"GotoTwo" sender:self];

//以modal 方式跳转
[self presentModalViewController:nil animated:YES];

// 以 modal跳转的返回方法
[self dismissModalViewControllerAnimated:YES];

//压进一个viewcontroller
[self.navigationController pushViewController:nil animated:YES];

//弹出一个viewcontroller  相当与返回上一个界面
[self.navigationController popViewControllerAnimated:YES];
```

#### 比较如下

|代码 | xib | storyboard
-|-|-|-
复用性|高|中|低
批量处理|高|低|低

### 布局
1. frame
2. Autolayout(推荐)
  * 缺点:
    * 没有占位符,一些界面需要使用看不见的view来占位
    * 某些常见的界面布局难以表述,如等间距
    * 需要设置很多约束,比较繁琐
    * 需要根据约束去求解位置,某些场合下比较耗时

### Size Class
按照View的尺寸大小分成几个类型,然后在xib/storyboard中根据类型设置不同约束.

设备宽高区分为`Compact`和`Regular`,不区分为`Any`.

所有设备的Size Class都是预先固定定义好的,比如iphone6竖屏时`wC hR`(w表示width,h表示height,C表示Compact,R表示Regular),ipad不管竖屏还是横屏都是`wR hR`

### Safe Area
用来避免内容被状态栏,导航栏,标签栏等覆盖.

IOS11前用的是`topLayoutGuide`与`bottomLayoutGuide`,IOS11开始用`safeAreaLayoutGuide`代替.

推荐不要把内容放到Safe Area外.

### First Responder & Exit
`First Responder`指任意对象在任意时间具有第一响应状态的代理对象.
比如某个输入框是First Responder时,按下按钮,给First Responder也就是输入框发送剪切的命令.
网上说实际用的不多.

`Exit`就是用来连线unwind segue的,看上面.

## MVC
* Controller直接引用View与Model
* View与Controller通信:
  * 设置View对应的Action Target,如设置 UIButton 的 Touch up inside 的 Action Target
  * 设置View的delegate,如UIAlertViewDelegate
  * 设置View的data source,如UITableViewDataSource
* Model与Controller通信:
  * Notification
  * KVO

## 其它问题
### 为什么字符串前要用`@`?
因为Objc与C语言兼容,如果不加,那么字符串会被编译器当作C语言的字符串.
那为什么不直接用C的字符串呢?因为NSString好用,方法多呗.

数字也是类似的道理.
