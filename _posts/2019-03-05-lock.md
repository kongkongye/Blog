---
layout: post
title:  Java锁的研究
categories: java
tags:  锁 Lock synchronized ReentrantLock
author: kongkongye
---

* content
{:toc}

Java锁的研究,包括锁分类等.




## 概念
* 原子性(atomicity): 指一个操作不可中断,要么全部成功要么全部失败
* 可见性(visibility): 指当一个线程修改了共享变量后,其他线程能立即得知这个修改(它要对付内存缓存和编译器优化的各种反常行为)
* 同步/异步: 同步指一个任务需要依赖另一个任务时,必须等待依赖的任务完成;异步指不需要等待依赖的任务完成.
* 阻塞/非阻塞: 从CPU消耗上说,阻塞就是CPU等待慢操作完成;非阻塞就是慢操作执行时CPU去干其他事.

## 锁分类

### 公平锁/非公平锁
公平锁是指线程按照申请锁的顺序来获取锁.

非公平锁的吞吐量更大.

`ReentrantLock`可以通过构造函数指定是否是公平锁,默认是非公平锁.

`synchronized`是非公平锁,并且没任何办法变成公平锁.

### 可重入锁
又名`递归锁`,指在外层获取锁后,在内层会自动获取锁.

可一定程度避免死锁.

`ReentrantLock`与`synchronized`都是可重入锁.

以下代码描述了可重入锁:

```java
synchronized void setA() {
  setB();
}
synchronized void setB() {
}
```

### 独享锁/共享锁
独享锁指该锁只能被一个线程持有,共享锁指该锁可以同时被多个线程持有.

`ReentrantLock`与`synchronized`是独享锁,`ReadWriteLock`的读锁是共享锁,写锁是独享锁

### 互斥锁/读写锁
`ReentrantLock`是互斥锁,`ReadWriteLock`是读写锁

### 乐观锁/悲观锁
指看待并发同步的角度,悲观锁假定会发生冲突,因此会加锁(在mysql角度,依靠数据库的加锁机制).
乐观锁假定不会发生冲突,只在提交时检测是否冲突,CAS(compare and swap)是最常见的乐观锁(在mysql角度,一般采用`版本号`方式实现,但乐观锁不能解决`脏读`问题)

乐观锁适合大量读操作的场景,会带来大量性能提升.

### 分段锁
分段锁是一种锁的设计.

`ConcurrentHashMap`使用的就是分段锁.

### 偏向锁/轻量级锁/重量级锁
这三种指的是`synchronized`锁的状态(jdk1.6后引入的).

偏向锁指一段代码一直被一个线程所访问,那么该线程会自动获取锁,降低获取锁的代价.

轻量级锁指锁是偏向锁的时候,被另一个线程所访问,偏向锁就会升级为轻量级锁,其它线程会通过自旋的形式尝试获取锁,不会阻塞,提高性能.

重量级锁指锁为轻量级锁的时候,另一个线程在自旋一定次数后,如果还没有获取到锁,就会进入阻塞,该锁升级为重量级锁.重量级锁会让其它申请的线程进入阻塞,性能降低.

### 自旋锁
自旋锁指尝试获取锁的进程不会立即阻塞,而是采用循环的方式去尝试获取锁,好处是减少线程上下文切换的消耗,坏处是会消耗CPU.

## 锁的优化
1. 减少锁持有时间
2. 减小锁粒度
3. 读写分离锁代替独占锁: 适合读多写少的情况
4. 锁分离: 像LinkedBlockingQueue, 把take()与put()分离
5. 锁粗化: 主要避免循环内反复申请锁

## 死锁

## synchronized
### 根据修饰对象分类
* 修饰代码块
    * `synchronized(this|object) {}`
    * `synchronized(类.class) {}`
* 修饰方法
    * 修饰非静态方法
    * 修饰静态方法

### 根据获取的锁分类
* 获取对象锁
    * `synchronized(this|object) {}`
    * 修饰非静态方法
* 获取类锁
    * `synchronized(类.class) {}`
    * 修饰静态方法

### 注意事项
* synchronized关键字不能继承: 父类方法有synchronized关键字,之类覆盖时不会继承,必须手动指定
* 定义接口方法时不能使用synchronized
* 构造方法不能使用synchronized,但可以使用synchronized代码块

## synchronized与ReentrantLock比较

### 共同点
* 都是协调多线程对变量的访问
* 都是可重入锁
* 都保证了可见性与互斥性

### 不同点
* ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁
* ReentrantLock可响应中断、可轮回，synchronized不可响应中断
* ReentrantLock是API级别的，synchronized是JVM级别的
* ReentrantLock可以实现公平锁
* ReentrantLock通过Condition可以绑定多个条件
* 底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略
* synchronized不支持分段加锁

### 性能
从jdk1.5后,jvm对synchronized进行了优化(偏向锁/轻量级锁...),性能就差不多了.
推荐只在synchronized无法满足的情况下使用ReentrantLock.

## wait & notify & notifyAll
先说两个概念:

* 锁池: 假设线程A拥有某个对象的锁,其他线程要获得锁,就会进入此对象的锁池
* 等待池: 假设线程A调用某个对象的wait()方法,就会释放锁,进入此对象的等待池

然后就很好理解:

* wait: 释放锁,并进入对象的锁池
* notify: (不释放锁)随机唤醒一个等待池中线程进入锁池
* notifyAll: (不释放锁)唤醒全部等待池中线程进入锁池

## sleep
线程sleep方法不会释放锁

### sleep与wait的区别
* wait释放锁,sleep不释放
* wait用来进行线程间通信,sleep用来在执行时暂停